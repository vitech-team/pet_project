language: java
jdk: oraclejdk8


before_script:
  - chmod +x ./gradlew

build:

  pre_ci_boot:
    image_name: vitechpetproject/ci
    image_tag: 0.1.4
    pull: true

  ci:
  - ./gradlew clean build jacocoRootReport sonarqube buildDockerImage -Dsonar.branch.name=$BRANCH

  always:
  - cp -r ./**/build/test-results/test/* shippable/testresults
  - cp -r ./build/target shippable/codecoverage
  - cp -r ./dev-flow-sample-ui/coverage/cobertura-coverage.xml shippable/codecoverage
  - cp -r ./dev-flow-sample-ui/coverage/junit.xml shippable/testresults


integrations:
  hub:
  - integrationName: DockerHub
    type: dockerRegistryLogin

resources:
# Terraform files repo
  - name: pet_project_terraform
    type: gitRepo
    integration: "github"
    versionTemplate:
      sourceName: "vitech-team/pet_project_terraform"
      branch: master
# AWS integration needed by Terraform
  - name: aws_keys
    type: integration
    integration: "aws"
# State resource to store Terraform State
  - name: aws_ecs_tf_state
    type: state
# Load balacer info output
  - name: alb_name
    type: params
    versionTemplate:
      params:
        SEED: "initial_version"
    #type: loadBalancer
    #integration: "aws"
    #pointer:
      #sourceName : "tbd" #name of the alb
jobs:
# Provision Cluster
  - name: pet_project_runCI
    type: runCI
    steps:
    - IN: pet_project_ciRepo
  - name: prov_aws_pet_project_ecs
    type: runSh
    steps:
      - IN: pet_project_runCI
      - IN: pet_project_terraform
      - IN: aws_keys
        switch: off
      - IN: aws_ecs_tf_state
        switch: off
      - TASK:
          name: prov_cluster
          runtime:
          script:
            - export AWS_ACCESS_KEY=$(shipctl get_integration_resource_field aws_keys "accessKey")
            - export AWS_SECRET_KEY=$(shipctl get_integration_resource_field aws_keys "secretKey")
            - pushd $(shipctl get_resource_state "pet_project_terraform")
            - shipctl replace terraform.tfvars
            - shipctl copy_file_from_resource_state aws_ecs_tf_state terraform.tfstate .
            - terraform init
            - terraform apply -auto-approve -var-file=terraform.tfvars
      - OUT: alb_name
        overwrite: true
      - OUT: aws_ecs_tf_state
    on_success:
      script:
        - shipctl put_resource_state_multi alb_name "alb_name=$(terraform output alb_hostname)"
    always:
      script:
        - shipctl copy_file_to_resource_state terraform.tfstate aws_ecs_tf_state

# Deprovision Cluster
  - name: deprov_aws_pet_project_ecs
    type: runSh
    steps:
      - IN: pet_project_terraform
        switch: off
      - IN: aws_keys
        switch: off
      - IN: aws_ecs_tf_state
        switch: off
      - TASK:
          name: prov_cluster
          runtime:
          script:
            - export AWS_ACCESS_KEY=$(shipctl get_integration_resource_field aws_keys "accessKey")
            - export AWS_SECRET_KEY=$(shipctl get_integration_resource_field aws_keys "secretKey")
            - pushd $(shipctl get_resource_state "pet_project_terraform")
            - shipctl replace terraform.tfvars
            - shipctl copy_file_from_resource_state aws_ecs_tf_state terraform.tfstate .
            - terraform init
            - terraform destroy -force -auto-approve -var-file=terraform.tfvars
      - OUT: alb_name
        overwrite: true
      - OUT: aws_ecs_tf_state
    on_success:
      script:
        - shipctl put_resource_state_multi alb_name "alb_name=$(terraform output alb_hostname)"
    always:
      script:
        - shipctl copy_file_to_resource_state terraform.tfstate aws_ecs_tf_state
